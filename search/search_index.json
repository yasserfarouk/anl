{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ANL Documentation This repository is the official platform for running ANAC Automated Negotiation Leagues (starting 2024). It will contain a package called anlXXXX for the competition run in year XXXX. For example anl2024 will contain all files related to the 2024's version of the competition. This package is a thin-wrapper around the NegMAS library for automated negotiation. Its main goal is to provide the following functionalities: A set of utility functions to run tournaments in the same settings as in the ANL competition. These functions are always called anl20XX_tournament for year 20XX . A CLI for running tournaments called anl . A place to hold the official implementation of every strategy submitted to the ANL competition after each year. These can be found in the module anl.anl20XX.negotiators for year 20XX . The official website for the ANL competition is: https://scml.cs.brown.edu/anl Installation pip install anl You can also install the in-development version with:: pip install https://github.com/autoneg/anl/archive/master.zip Documentation https://yasserfarouk.github.io/anl/ CLI After installation, you can try running a tournament using the CLI as: anl tournament2024 To find all the parameters you can customize for running tournaments run: anl tournament2024 --help","title":"Index"},{"location":"#anl-documentation","text":"This repository is the official platform for running ANAC Automated Negotiation Leagues (starting 2024). It will contain a package called anlXXXX for the competition run in year XXXX. For example anl2024 will contain all files related to the 2024's version of the competition. This package is a thin-wrapper around the NegMAS library for automated negotiation. Its main goal is to provide the following functionalities: A set of utility functions to run tournaments in the same settings as in the ANL competition. These functions are always called anl20XX_tournament for year 20XX . A CLI for running tournaments called anl . A place to hold the official implementation of every strategy submitted to the ANL competition after each year. These can be found in the module anl.anl20XX.negotiators for year 20XX . The official website for the ANL competition is: https://scml.cs.brown.edu/anl","title":"ANL Documentation"},{"location":"#installation","text":"pip install anl You can also install the in-development version with:: pip install https://github.com/autoneg/anl/archive/master.zip","title":"Installation"},{"location":"#documentation","text":"https://yasserfarouk.github.io/anl/","title":"Documentation"},{"location":"#cli","text":"After installation, you can try running a tournament using the CLI as: anl tournament2024 To find all the parameters you can customize for running tournaments run: anl tournament2024 --help","title":"CLI"},{"location":"faq/","text":"FAQ === FAQ === How can I access a data file in my package? When your agent is submitted, it is run in an environment different from that in which the tournament will be run. This means that you cannot use hardcoded paths in your agent. Moreover, you (and we) do not know in advance what will be the current directory when the tournament is run. For this reason, it is required that if you access any files in your agent, you should use a path relative to the file in which the code accessing these files is located. Please note that accessing ANY FILES outside the directory of your agent is prohibited and will lead to immediate disqualification for obvious security reasons. There are no second chances in this one. Let's assume that your file structure is something like that: :: base \u251c\u2500\u2500 sub \u2502 \u251c\u2500\u2500 myagent.py \u2502 \u2514\u2500\u2500 otherfiles.py \u251c\u2500\u2500 data \u2502 \u2514\u2500\u2500 myfile.csv \u2514\u2500\u2500 tests Now you want to access the file myfile.csv when you are inside myagent.py . To do so you can use the following code:: import pathlib path_2_myfile = pathlib.Path(__file__).parent.parent / \"data\" / \"myfile.csv\" Can my agent pass data to my other agents between negotiations? NO Passing data to your agents between negotiations will lead to disqualification. Can my agent read data from the HDD outside my agent's folder? NO Your agent can only read files that you submitted to us in your zip file. It cannot modify these files in anyway during the competition. It cannot read from anywhere else in secondary storage. Trying to do so will lead to disqualification. Can my agent write data to the HDD during the negotiation? NO The agent is not allowed to write anything to the hard disk during the competition. Can I print to the screen to debug my agent? PLEASE DO NOT Printing to the screen in your agent will prevent us from monitoring the progress of tournament runs and will slow down the process. Moreover, it is not useful anyway because the tournaments are run in parallel. If you really need to print something (e.g. for debugging purposes), please remove all print statements before submission. We will never touch your code after submission so we cannot remove them. Can I write arbitrary code in my module besides the negotiator class definition? When python imports your module, it runs everything in it so the top level code should be only one of these: - Class definitions - Function definitions - Variable definitions - Arbitrary code that runs in few milliseconds and prints nothing Any other code must be protected inside:: if __name__ == \"__main__\" For example, if you want to run a simulation to test your agent. DO NOT USE SOMETHING LIKE THIS :: anl2024_tournament(....) But something like this:: def main(): anl2024_tournament(....) if __name__ == \"__main__\": main() This way, importing your module will not run the world simulation. I ran a simulation using \"anl tournament2024\" command. Where are my log files? If you did not pass \"--no-log\", you will find the log files at ~/negmas/anl2024/[date-time-uuid] I implement my agent using multiple files. How should I import them? Assume that you have the following file structure :: base \u251c\u2500\u2500 subfolder \u2502 \u2514\u2500\u2500 component2.py \u251c\u2500\u2500 component1.py \u2514\u2500\u2500 agent.py In your agent.py file, you want to import your other files:: import component1 import subfolder.component2 This will not work because in the actual competition component1.py and component2.py will not be in python path. There are two ways to solve it: The clean way is to use relative imports. You will need to turn your agent int a package by adding empty __init__.py files to every folder you want to import from:: base \u251c\u2500\u2500 sub \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 component2.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 component1.py \u2514\u2500\u2500 agent.py You can now change your import to:: import .component1 import .subfolder.component2 Notice the extra dot ( . ) Another way that does not require any modification of your file structure is to add the following lines before your imports:: import os, sys sys.path.append(os.path.dirname(__file__)) Note that the later method has the disadvantage of putting your components at the end of the path which means that if you have any classes, functions, etc with a name that is defined in any module that appears earlier in the path, yours will be hidden.","title":"Reference"},{"location":"faq/#faq","text":"=== FAQ ===","title":"FAQ"},{"location":"faq/#how-can-i-access-a-data-file-in-my-package","text":"When your agent is submitted, it is run in an environment different from that in which the tournament will be run. This means that you cannot use hardcoded paths in your agent. Moreover, you (and we) do not know in advance what will be the current directory when the tournament is run. For this reason, it is required that if you access any files in your agent, you should use a path relative to the file in which the code accessing these files is located. Please note that accessing ANY FILES outside the directory of your agent is prohibited and will lead to immediate disqualification for obvious security reasons. There are no second chances in this one. Let's assume that your file structure is something like that: :: base \u251c\u2500\u2500 sub \u2502 \u251c\u2500\u2500 myagent.py \u2502 \u2514\u2500\u2500 otherfiles.py \u251c\u2500\u2500 data \u2502 \u2514\u2500\u2500 myfile.csv \u2514\u2500\u2500 tests Now you want to access the file myfile.csv when you are inside myagent.py . To do so you can use the following code:: import pathlib path_2_myfile = pathlib.Path(__file__).parent.parent / \"data\" / \"myfile.csv\"","title":"How can I access a data file in my package?"},{"location":"faq/#can-my-agent-pass-data-to-my-other-agents-between-negotiations","text":"NO Passing data to your agents between negotiations will lead to disqualification.","title":"Can my agent pass data to my other agents between negotiations?"},{"location":"faq/#can-my-agent-read-data-from-the-hdd-outside-my-agents-folder","text":"NO Your agent can only read files that you submitted to us in your zip file. It cannot modify these files in anyway during the competition. It cannot read from anywhere else in secondary storage. Trying to do so will lead to disqualification.","title":"Can my agent read data from the HDD outside my agent's folder?"},{"location":"faq/#can-my-agent-write-data-to-the-hdd-during-the-negotiation","text":"NO The agent is not allowed to write anything to the hard disk during the competition.","title":"Can my agent write data to the HDD during the negotiation?"},{"location":"faq/#can-i-print-to-the-screen-to-debug-my-agent","text":"PLEASE DO NOT Printing to the screen in your agent will prevent us from monitoring the progress of tournament runs and will slow down the process. Moreover, it is not useful anyway because the tournaments are run in parallel. If you really need to print something (e.g. for debugging purposes), please remove all print statements before submission. We will never touch your code after submission so we cannot remove them.","title":"Can I print to the screen to debug my agent?"},{"location":"faq/#can-i-write-arbitrary-code-in-my-module-besides-the-negotiator-class-definition","text":"When python imports your module, it runs everything in it so the top level code should be only one of these: - Class definitions - Function definitions - Variable definitions - Arbitrary code that runs in few milliseconds and prints nothing Any other code must be protected inside:: if __name__ == \"__main__\" For example, if you want to run a simulation to test your agent. DO NOT USE SOMETHING LIKE THIS :: anl2024_tournament(....) But something like this:: def main(): anl2024_tournament(....) if __name__ == \"__main__\": main() This way, importing your module will not run the world simulation.","title":"Can I write arbitrary code in my module besides the negotiator class definition?"},{"location":"faq/#i-ran-a-simulation-using-anl-tournament2024-command-where-are-my-log-files","text":"If you did not pass \"--no-log\", you will find the log files at ~/negmas/anl2024/[date-time-uuid]","title":"I ran a simulation using \"anl tournament2024\" command. Where are my log files?"},{"location":"faq/#i-implement-my-agent-using-multiple-files-how-should-i-import-them","text":"Assume that you have the following file structure :: base \u251c\u2500\u2500 subfolder \u2502 \u2514\u2500\u2500 component2.py \u251c\u2500\u2500 component1.py \u2514\u2500\u2500 agent.py In your agent.py file, you want to import your other files:: import component1 import subfolder.component2 This will not work because in the actual competition component1.py and component2.py will not be in python path. There are two ways to solve it: The clean way is to use relative imports. You will need to turn your agent int a package by adding empty __init__.py files to every folder you want to import from:: base \u251c\u2500\u2500 sub \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 component2.py \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 component1.py \u2514\u2500\u2500 agent.py You can now change your import to:: import .component1 import .subfolder.component2 Notice the extra dot ( . ) Another way that does not require any modification of your file structure is to add the following lines before your imports:: import os, sys sys.path.append(os.path.dirname(__file__)) Note that the later method has the disadvantage of putting your components at the end of the path which means that if you have any classes, functions, etc with a name that is defined in any module that appears earlier in the path, yours will be hidden.","title":"I implement my agent using multiple files. How should I import them?"},{"location":"reference/","text":"ANL The core functionality of this package is provided by NegMAS. ANL2024 function: anl2024_tournament Runs an ANL 2024 tournament Parameters: Name Type Description Default n_scenarios int Number of negotiation scenarios 20 n_outcomes int | tuple [ int , int ] Number of outcomes (or a min/max tuple of n. outcomes) for each scenario 100 competitors tuple [ type [ Negotiator ] | str , ...] | list [ type [ Negotiator ] | str ] list of competitor agents DEFAULT_AN2024_COMPETITORS competitor_params Sequence [ dict | None] | None If given, parameters to construct each competitor None rotate_ufuns bool If given, each scenario will be tried with both orders of the ufuns. True n_repetitions int Number of times to repeat each negotiation 5 n_steps int | None Number of steps (rounds) per negotiation. None means no limit 100 time_limit float | None Number of seconds per negotiation. None means no limit None pend float Probability of ending the negotiation each round. 0.0 name str | None Name of the tournament None nologs bool If given, no logs will be saved False njobs int Number of parallel jobs to use. -1 for serial and 0 for all cores 0 plot_fraction float Fraction of negotiations to plot. Only used if not nologs 0.2 verbosity int Verbosity level. The higher the more verbose 1 self_play bool Allow negotiators to run against themselves. True randomize_runs bool Randomize the order of negotiations True save_every int Save logs every this number of negotiations 0 save_stats bool Save statistics for scenarios True known_partner bool Allow negotiators to know the type of their partner (through their ID) False final_score tuple [ str , str ] The metric and statistic used to calculate the score. Metrics are: advantage, utility, welfare, partner_welfare and Stats are: median, mean, std, min, max ('advantage', 'mean') base_path Path | None Folder in which to generate the logs folder for this tournament. Default is ~/negmas/anl2024/tournaments None scenario_generator Callable [[ int , int | tuple [ int , int ]], list [ Scenario ]] An alternative method for generating bilateral negotiation scenarios. Must receive the number of scenarios and number of outcomes. make_scenarios Returns: Type Description SimpleTournamentResults Tournament results as a SimpleTournamentResults object. Source code in anl/anl2024/runner.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def anl2024_tournament ( n_scenarios : int = 20 , n_outcomes : int | tuple [ int , int ] = 100 , competitors : tuple [ type [ Negotiator ] | str , ... ] | list [ type [ Negotiator ] | str ] = DEFAULT_AN2024_COMPETITORS , competitor_params : Sequence [ dict | None ] | None = None , rotate_ufuns : bool = True , n_repetitions : int = 5 , n_steps : int | None = 100 , time_limit : float | None = None , pend : float = 0.0 , name : str | None = None , nologs : bool = False , njobs : int = 0 , plot_fraction : float = 0.2 , verbosity : int = 1 , self_play : bool = True , randomize_runs : bool = True , save_every : int = 0 , save_stats : bool = True , known_partner : bool = False , final_score : tuple [ str , str ] = ( \"advantage\" , \"mean\" ), base_path : Path | None = None , scenario_generator : Callable [[ int , int | tuple [ int , int ]], list [ Scenario ]] = make_scenarios ) -> SimpleTournamentResults : \"\"\"Runs an ANL 2024 tournament Args: n_scenarios: Number of negotiation scenarios n_outcomes: Number of outcomes (or a min/max tuple of n. outcomes) for each scenario competitors: list of competitor agents competitor_params: If given, parameters to construct each competitor rotate_ufuns: If given, each scenario will be tried with both orders of the ufuns. n_repetitions: Number of times to repeat each negotiation n_steps: Number of steps (rounds) per negotiation. None means no limit time_limit: Number of seconds per negotiation. None means no limit pend: Probability of ending the negotiation each round. name: Name of the tournament nologs: If given, no logs will be saved njobs: Number of parallel jobs to use. -1 for serial and 0 for all cores plot_fraction: Fraction of negotiations to plot. Only used if not nologs verbosity: Verbosity level. The higher the more verbose self_play: Allow negotiators to run against themselves. randomize_runs: Randomize the order of negotiations save_every: Save logs every this number of negotiations save_stats: Save statistics for scenarios known_partner: Allow negotiators to know the type of their partner (through their ID) final_score: The metric and statistic used to calculate the score. Metrics are: advantage, utility, welfare, partner_welfare and Stats are: median, mean, std, min, max base_path: Folder in which to generate the logs folder for this tournament. Default is ~/negmas/anl2024/tournaments scenario_generator: An alternative method for generating bilateral negotiation scenarios. Must receive the number of scenarios and number of outcomes. Returns: Tournament results as a `SimpleTournamentResults` object. \"\"\" if nologs : path = None elif base_path is not None : path = Path ( base_path ) / ( name if name else unique_name ( \"anl\" )) else : path = DEFAULT_TOURNAMENT_PATH / ( name if name else unique_name ( \"anl\" )) return cartesian_tournament ( competitors = tuple ( competitors ), scenarios = scenario_generator ( n_scenarios , n_outcomes ), competitor_params = competitor_params , rotate_ufuns = rotate_ufuns , n_repetitions = n_repetitions , path = path , njobs = njobs , mechanism_type = SAOMechanism , mechanism_params = dict ( time_limit = time_limit , n_steps = n_steps , pend = pend ), plot_fraction = plot_fraction , verbosity = verbosity , self_play = self_play , randomize_runs = randomize_runs , save_every = save_every , save_stats = save_stats , final_score = final_score , id_reveals_type = known_partner , name_reveals_type = True , ) function: make_scenarios Creates n_scenarios scenarios of the divide-the-pie domain all of n_outcomes outcomes and with different reserved value combinations that fall within reserved_ranges Source code in anl/anl2024/runner.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def make_scenarios ( n_scenarios : int = 20 , n_outcomes : int | tuple [ int , int ] = 100 , * , reserved_ranges : RESERVED_RANGES = (( 0.0 , 0.499999 ), ( 0.0 , 0.499999 )), ) -> list [ Scenario ]: \"\"\"Creates `n_scenarios` scenarios of the divide-the-pie domain all of `n_outcomes` outcomes and with different reserved value combinations that fall within `reserved_ranges` \"\"\" n = onein ( n_outcomes ) issues = ( make_issue ([ f \" { i } _ { n - 1 - i } \" for i in range ( n )], \"portions\" ), ) ufun_sets = [ tuple ( U ( values = ( TableFun ( { _ : int ( str ( _ ) . split ( \"_\" )[ k ]) / ( n - 1 ) for _ in issues [ 0 ] . all } ), ), name = f \" { uname }{ i } \" , reserved_value = ( r [ 0 ] + 1e-8 + random . random () * ( r [ 1 ] - r [ 0 ] - 1e-8 )), outcome_space = make_os ( issues , name = f \"DivideTyePie { i } \" ), ) for k , ( uname , r ) in enumerate ( zip (( \"First\" , \"Second\" ), reserved_ranges )) ) for i in range ( n_scenarios ) ] return [ Scenario ( outcome_space = ufuns [ 0 ] . outcome_space , # type: ignore We are sure this is not None ufuns = ufuns , ) for ufuns in ufun_sets ]","title":"Reference"},{"location":"reference/#anl","text":"The core functionality of this package is provided by NegMAS.","title":"ANL"},{"location":"reference/#anl2024","text":"","title":"ANL2024"},{"location":"reference/#function-anl2024_tournament","text":"Runs an ANL 2024 tournament Parameters: Name Type Description Default n_scenarios int Number of negotiation scenarios 20 n_outcomes int | tuple [ int , int ] Number of outcomes (or a min/max tuple of n. outcomes) for each scenario 100 competitors tuple [ type [ Negotiator ] | str , ...] | list [ type [ Negotiator ] | str ] list of competitor agents DEFAULT_AN2024_COMPETITORS competitor_params Sequence [ dict | None] | None If given, parameters to construct each competitor None rotate_ufuns bool If given, each scenario will be tried with both orders of the ufuns. True n_repetitions int Number of times to repeat each negotiation 5 n_steps int | None Number of steps (rounds) per negotiation. None means no limit 100 time_limit float | None Number of seconds per negotiation. None means no limit None pend float Probability of ending the negotiation each round. 0.0 name str | None Name of the tournament None nologs bool If given, no logs will be saved False njobs int Number of parallel jobs to use. -1 for serial and 0 for all cores 0 plot_fraction float Fraction of negotiations to plot. Only used if not nologs 0.2 verbosity int Verbosity level. The higher the more verbose 1 self_play bool Allow negotiators to run against themselves. True randomize_runs bool Randomize the order of negotiations True save_every int Save logs every this number of negotiations 0 save_stats bool Save statistics for scenarios True known_partner bool Allow negotiators to know the type of their partner (through their ID) False final_score tuple [ str , str ] The metric and statistic used to calculate the score. Metrics are: advantage, utility, welfare, partner_welfare and Stats are: median, mean, std, min, max ('advantage', 'mean') base_path Path | None Folder in which to generate the logs folder for this tournament. Default is ~/negmas/anl2024/tournaments None scenario_generator Callable [[ int , int | tuple [ int , int ]], list [ Scenario ]] An alternative method for generating bilateral negotiation scenarios. Must receive the number of scenarios and number of outcomes. make_scenarios Returns: Type Description SimpleTournamentResults Tournament results as a SimpleTournamentResults object. Source code in anl/anl2024/runner.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def anl2024_tournament ( n_scenarios : int = 20 , n_outcomes : int | tuple [ int , int ] = 100 , competitors : tuple [ type [ Negotiator ] | str , ... ] | list [ type [ Negotiator ] | str ] = DEFAULT_AN2024_COMPETITORS , competitor_params : Sequence [ dict | None ] | None = None , rotate_ufuns : bool = True , n_repetitions : int = 5 , n_steps : int | None = 100 , time_limit : float | None = None , pend : float = 0.0 , name : str | None = None , nologs : bool = False , njobs : int = 0 , plot_fraction : float = 0.2 , verbosity : int = 1 , self_play : bool = True , randomize_runs : bool = True , save_every : int = 0 , save_stats : bool = True , known_partner : bool = False , final_score : tuple [ str , str ] = ( \"advantage\" , \"mean\" ), base_path : Path | None = None , scenario_generator : Callable [[ int , int | tuple [ int , int ]], list [ Scenario ]] = make_scenarios ) -> SimpleTournamentResults : \"\"\"Runs an ANL 2024 tournament Args: n_scenarios: Number of negotiation scenarios n_outcomes: Number of outcomes (or a min/max tuple of n. outcomes) for each scenario competitors: list of competitor agents competitor_params: If given, parameters to construct each competitor rotate_ufuns: If given, each scenario will be tried with both orders of the ufuns. n_repetitions: Number of times to repeat each negotiation n_steps: Number of steps (rounds) per negotiation. None means no limit time_limit: Number of seconds per negotiation. None means no limit pend: Probability of ending the negotiation each round. name: Name of the tournament nologs: If given, no logs will be saved njobs: Number of parallel jobs to use. -1 for serial and 0 for all cores plot_fraction: Fraction of negotiations to plot. Only used if not nologs verbosity: Verbosity level. The higher the more verbose self_play: Allow negotiators to run against themselves. randomize_runs: Randomize the order of negotiations save_every: Save logs every this number of negotiations save_stats: Save statistics for scenarios known_partner: Allow negotiators to know the type of their partner (through their ID) final_score: The metric and statistic used to calculate the score. Metrics are: advantage, utility, welfare, partner_welfare and Stats are: median, mean, std, min, max base_path: Folder in which to generate the logs folder for this tournament. Default is ~/negmas/anl2024/tournaments scenario_generator: An alternative method for generating bilateral negotiation scenarios. Must receive the number of scenarios and number of outcomes. Returns: Tournament results as a `SimpleTournamentResults` object. \"\"\" if nologs : path = None elif base_path is not None : path = Path ( base_path ) / ( name if name else unique_name ( \"anl\" )) else : path = DEFAULT_TOURNAMENT_PATH / ( name if name else unique_name ( \"anl\" )) return cartesian_tournament ( competitors = tuple ( competitors ), scenarios = scenario_generator ( n_scenarios , n_outcomes ), competitor_params = competitor_params , rotate_ufuns = rotate_ufuns , n_repetitions = n_repetitions , path = path , njobs = njobs , mechanism_type = SAOMechanism , mechanism_params = dict ( time_limit = time_limit , n_steps = n_steps , pend = pend ), plot_fraction = plot_fraction , verbosity = verbosity , self_play = self_play , randomize_runs = randomize_runs , save_every = save_every , save_stats = save_stats , final_score = final_score , id_reveals_type = known_partner , name_reveals_type = True , )","title":"function: anl2024_tournament"},{"location":"reference/#function-make_scenarios","text":"Creates n_scenarios scenarios of the divide-the-pie domain all of n_outcomes outcomes and with different reserved value combinations that fall within reserved_ranges Source code in anl/anl2024/runner.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def make_scenarios ( n_scenarios : int = 20 , n_outcomes : int | tuple [ int , int ] = 100 , * , reserved_ranges : RESERVED_RANGES = (( 0.0 , 0.499999 ), ( 0.0 , 0.499999 )), ) -> list [ Scenario ]: \"\"\"Creates `n_scenarios` scenarios of the divide-the-pie domain all of `n_outcomes` outcomes and with different reserved value combinations that fall within `reserved_ranges` \"\"\" n = onein ( n_outcomes ) issues = ( make_issue ([ f \" { i } _ { n - 1 - i } \" for i in range ( n )], \"portions\" ), ) ufun_sets = [ tuple ( U ( values = ( TableFun ( { _ : int ( str ( _ ) . split ( \"_\" )[ k ]) / ( n - 1 ) for _ in issues [ 0 ] . all } ), ), name = f \" { uname }{ i } \" , reserved_value = ( r [ 0 ] + 1e-8 + random . random () * ( r [ 1 ] - r [ 0 ] - 1e-8 )), outcome_space = make_os ( issues , name = f \"DivideTyePie { i } \" ), ) for k , ( uname , r ) in enumerate ( zip (( \"First\" , \"Second\" ), reserved_ranges )) ) for i in range ( n_scenarios ) ] return [ Scenario ( outcome_space = ufuns [ 0 ] . outcome_space , # type: ignore We are sure this is not None ufuns = ufuns , ) for ufuns in ufun_sets ]","title":"function: make_scenarios"}]}