{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ANL Documentation for the ANL package used to run ANAC's Automated Negotiation Leagu. ANL2024 Utility functions used to run ANL 2024 function: anl2024_tournament Runs an ANL 2024 tournament Parameters: Name Type Description Default n_scenarios int Number of negotiation scenarios 20 n_outcomes int | tuple [ int , int ] Number of outcomes (or a min/max tuple of n. outcomes) for each scenario 100 competitors tuple [ type [ Negotiator ] | str , ...] | list [ type [ Negotiator ] | str ] list of competitor agents DEFAULT_AN2024_COMPETITORS competitor_params Sequence [ dict | None] | None If given, parameters to construct each competitor None rotate_ufuns bool If given, each scenario will be tried with both orders of the ufuns. True n_repetitions int Number of times to repeat each negotiation 5 n_steps int | None Number of steps (rounds) per negotiation. None means no limit 100 time_limit float | None Number of seconds per negotiation. None means no limit None pend float Probability of ending the negotiation each round. 0.0 name str | None Name of the tournament None nologs bool If given, no logs will be saved False njobs int Number of parallel jobs to use. -1 for serial and 0 for all cores 0 plot_fraction float Fraction of negotiations to plot. Only used if not nologs 0.2 verbosity int Verbosity level. The higher the more verbose 1 self_play bool Allow negotiators to run against themselves. True randomize_runs bool Randomize the order of negotiations True save_every int Save logs every this number of negotiations 0 save_stats bool Save statistics for scenarios True known_partner bool Allow negotiators to know the type of their partner (through their ID) False final_score tuple [ str , str ] The metric and statistic used to calculate the score. Metrics are: advantage, utility, welfare, partner_welfare and Stats are: median, mean, std, min, max ('advantage', 'mean') base_path Path | None Folder in which to generate the logs folder for this tournament. Default is ~/negmas/anl2024/tournaments None scenario_generator Callable [[ int , int | tuple [ int , int ]], list [ Scenario ]] An alternative method for generating bilateral negotiation scenarios. Must receive the number of scenarios and number of outcomes. make_scenarios Returns: Type Description SimpleTournamentResults Tournament results as a SimpleTournamentResults object. Source code in anl/anl2024/runner.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def anl2024_tournament ( n_scenarios : int = 20 , n_outcomes : int | tuple [ int , int ] = 100 , competitors : tuple [ type [ Negotiator ] | str , ... ] | list [ type [ Negotiator ] | str ] = DEFAULT_AN2024_COMPETITORS , competitor_params : Sequence [ dict | None ] | None = None , rotate_ufuns : bool = True , n_repetitions : int = 5 , n_steps : int | None = 100 , time_limit : float | None = None , pend : float = 0.0 , name : str | None = None , nologs : bool = False , njobs : int = 0 , plot_fraction : float = 0.2 , verbosity : int = 1 , self_play : bool = True , randomize_runs : bool = True , save_every : int = 0 , save_stats : bool = True , known_partner : bool = False , final_score : tuple [ str , str ] = ( \"advantage\" , \"mean\" ), base_path : Path | None = None , scenario_generator : Callable [[ int , int | tuple [ int , int ]], list [ Scenario ]] = make_scenarios ) -> SimpleTournamentResults : \"\"\"Runs an ANL 2024 tournament Args: n_scenarios: Number of negotiation scenarios n_outcomes: Number of outcomes (or a min/max tuple of n. outcomes) for each scenario competitors: list of competitor agents competitor_params: If given, parameters to construct each competitor rotate_ufuns: If given, each scenario will be tried with both orders of the ufuns. n_repetitions: Number of times to repeat each negotiation n_steps: Number of steps (rounds) per negotiation. None means no limit time_limit: Number of seconds per negotiation. None means no limit pend: Probability of ending the negotiation each round. name: Name of the tournament nologs: If given, no logs will be saved njobs: Number of parallel jobs to use. -1 for serial and 0 for all cores plot_fraction: Fraction of negotiations to plot. Only used if not nologs verbosity: Verbosity level. The higher the more verbose self_play: Allow negotiators to run against themselves. randomize_runs: Randomize the order of negotiations save_every: Save logs every this number of negotiations save_stats: Save statistics for scenarios known_partner: Allow negotiators to know the type of their partner (through their ID) final_score: The metric and statistic used to calculate the score. Metrics are: advantage, utility, welfare, partner_welfare and Stats are: median, mean, std, min, max base_path: Folder in which to generate the logs folder for this tournament. Default is ~/negmas/anl2024/tournaments scenario_generator: An alternative method for generating bilateral negotiation scenarios. Must receive the number of scenarios and number of outcomes. Returns: Tournament results as a `SimpleTournamentResults` object. \"\"\" if nologs : path = None elif base_path is not None : path = Path ( base_path ) / ( name if name else unique_name ( \"anl\" )) else : path = DEFAULT_TOURNAMENT_PATH / ( name if name else unique_name ( \"anl\" )) return cartesian_tournament ( competitors = tuple ( competitors ), scenarios = scenario_generator ( n_scenarios , n_outcomes ), competitor_params = competitor_params , rotate_ufuns = rotate_ufuns , n_repetitions = n_repetitions , path = path , njobs = njobs , mechanism_type = SAOMechanism , mechanism_params = dict ( time_limit = time_limit , n_steps = n_steps , pend = pend ), plot_fraction = plot_fraction , verbosity = verbosity , self_play = self_play , randomize_runs = randomize_runs , save_every = save_every , save_stats = save_stats , final_score = final_score , id_reveals_type = known_partner , name_reveals_type = True , ) function: make_scenarios Creates n_scenarios scenarios of the divide-the-pie domain all of n_outcomes outcomes and with different reserved value combinations that fall within reserved_ranges Source code in anl/anl2024/runner.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def make_scenarios ( n_scenarios : int = 20 , n_outcomes : int | tuple [ int , int ] = 100 , * , reserved_ranges : RESERVED_RANGES = (( 0.0 , 0.499999 ), ( 0.0 , 0.499999 )), ) -> list [ Scenario ]: \"\"\"Creates `n_scenarios` scenarios of the divide-the-pie domain all of `n_outcomes` outcomes and with different reserved value combinations that fall within `reserved_ranges` \"\"\" n = onein ( n_outcomes ) issues = ( make_issue ([ f \" { i } _ { n - 1 - i } \" for i in range ( n )], \"portions\" ), ) ufun_sets = [ tuple ( U ( values = ( TableFun ( { _ : int ( str ( _ ) . split ( \"_\" )[ k ]) / ( n - 1 ) for _ in issues [ 0 ] . all } ), ), name = f \" { uname }{ i } \" , reserved_value = ( r [ 0 ] + 1e-8 + random . random () * ( r [ 1 ] - r [ 0 ] - 1e-8 )), outcome_space = make_os ( issues , name = f \"DivideTyePie { i } \" ), ) for k , ( uname , r ) in enumerate ( zip (( \"First\" , \"Second\" ), reserved_ranges )) ) for i in range ( n_scenarios ) ] return [ Scenario ( outcome_space = ufuns [ 0 ] . outcome_space , # type: ignore We are sure this is not None ufuns = ufuns , ) for ufuns in ufun_sets ]","title":"Home"},{"location":"#anl","text":"Documentation for the ANL package used to run ANAC's Automated Negotiation Leagu.","title":"ANL"},{"location":"#anl2024","text":"Utility functions used to run ANL 2024","title":"ANL2024"},{"location":"#function-anl2024_tournament","text":"Runs an ANL 2024 tournament Parameters: Name Type Description Default n_scenarios int Number of negotiation scenarios 20 n_outcomes int | tuple [ int , int ] Number of outcomes (or a min/max tuple of n. outcomes) for each scenario 100 competitors tuple [ type [ Negotiator ] | str , ...] | list [ type [ Negotiator ] | str ] list of competitor agents DEFAULT_AN2024_COMPETITORS competitor_params Sequence [ dict | None] | None If given, parameters to construct each competitor None rotate_ufuns bool If given, each scenario will be tried with both orders of the ufuns. True n_repetitions int Number of times to repeat each negotiation 5 n_steps int | None Number of steps (rounds) per negotiation. None means no limit 100 time_limit float | None Number of seconds per negotiation. None means no limit None pend float Probability of ending the negotiation each round. 0.0 name str | None Name of the tournament None nologs bool If given, no logs will be saved False njobs int Number of parallel jobs to use. -1 for serial and 0 for all cores 0 plot_fraction float Fraction of negotiations to plot. Only used if not nologs 0.2 verbosity int Verbosity level. The higher the more verbose 1 self_play bool Allow negotiators to run against themselves. True randomize_runs bool Randomize the order of negotiations True save_every int Save logs every this number of negotiations 0 save_stats bool Save statistics for scenarios True known_partner bool Allow negotiators to know the type of their partner (through their ID) False final_score tuple [ str , str ] The metric and statistic used to calculate the score. Metrics are: advantage, utility, welfare, partner_welfare and Stats are: median, mean, std, min, max ('advantage', 'mean') base_path Path | None Folder in which to generate the logs folder for this tournament. Default is ~/negmas/anl2024/tournaments None scenario_generator Callable [[ int , int | tuple [ int , int ]], list [ Scenario ]] An alternative method for generating bilateral negotiation scenarios. Must receive the number of scenarios and number of outcomes. make_scenarios Returns: Type Description SimpleTournamentResults Tournament results as a SimpleTournamentResults object. Source code in anl/anl2024/runner.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def anl2024_tournament ( n_scenarios : int = 20 , n_outcomes : int | tuple [ int , int ] = 100 , competitors : tuple [ type [ Negotiator ] | str , ... ] | list [ type [ Negotiator ] | str ] = DEFAULT_AN2024_COMPETITORS , competitor_params : Sequence [ dict | None ] | None = None , rotate_ufuns : bool = True , n_repetitions : int = 5 , n_steps : int | None = 100 , time_limit : float | None = None , pend : float = 0.0 , name : str | None = None , nologs : bool = False , njobs : int = 0 , plot_fraction : float = 0.2 , verbosity : int = 1 , self_play : bool = True , randomize_runs : bool = True , save_every : int = 0 , save_stats : bool = True , known_partner : bool = False , final_score : tuple [ str , str ] = ( \"advantage\" , \"mean\" ), base_path : Path | None = None , scenario_generator : Callable [[ int , int | tuple [ int , int ]], list [ Scenario ]] = make_scenarios ) -> SimpleTournamentResults : \"\"\"Runs an ANL 2024 tournament Args: n_scenarios: Number of negotiation scenarios n_outcomes: Number of outcomes (or a min/max tuple of n. outcomes) for each scenario competitors: list of competitor agents competitor_params: If given, parameters to construct each competitor rotate_ufuns: If given, each scenario will be tried with both orders of the ufuns. n_repetitions: Number of times to repeat each negotiation n_steps: Number of steps (rounds) per negotiation. None means no limit time_limit: Number of seconds per negotiation. None means no limit pend: Probability of ending the negotiation each round. name: Name of the tournament nologs: If given, no logs will be saved njobs: Number of parallel jobs to use. -1 for serial and 0 for all cores plot_fraction: Fraction of negotiations to plot. Only used if not nologs verbosity: Verbosity level. The higher the more verbose self_play: Allow negotiators to run against themselves. randomize_runs: Randomize the order of negotiations save_every: Save logs every this number of negotiations save_stats: Save statistics for scenarios known_partner: Allow negotiators to know the type of their partner (through their ID) final_score: The metric and statistic used to calculate the score. Metrics are: advantage, utility, welfare, partner_welfare and Stats are: median, mean, std, min, max base_path: Folder in which to generate the logs folder for this tournament. Default is ~/negmas/anl2024/tournaments scenario_generator: An alternative method for generating bilateral negotiation scenarios. Must receive the number of scenarios and number of outcomes. Returns: Tournament results as a `SimpleTournamentResults` object. \"\"\" if nologs : path = None elif base_path is not None : path = Path ( base_path ) / ( name if name else unique_name ( \"anl\" )) else : path = DEFAULT_TOURNAMENT_PATH / ( name if name else unique_name ( \"anl\" )) return cartesian_tournament ( competitors = tuple ( competitors ), scenarios = scenario_generator ( n_scenarios , n_outcomes ), competitor_params = competitor_params , rotate_ufuns = rotate_ufuns , n_repetitions = n_repetitions , path = path , njobs = njobs , mechanism_type = SAOMechanism , mechanism_params = dict ( time_limit = time_limit , n_steps = n_steps , pend = pend ), plot_fraction = plot_fraction , verbosity = verbosity , self_play = self_play , randomize_runs = randomize_runs , save_every = save_every , save_stats = save_stats , final_score = final_score , id_reveals_type = known_partner , name_reveals_type = True , )","title":"function: anl2024_tournament"},{"location":"#function-make_scenarios","text":"Creates n_scenarios scenarios of the divide-the-pie domain all of n_outcomes outcomes and with different reserved value combinations that fall within reserved_ranges Source code in anl/anl2024/runner.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def make_scenarios ( n_scenarios : int = 20 , n_outcomes : int | tuple [ int , int ] = 100 , * , reserved_ranges : RESERVED_RANGES = (( 0.0 , 0.499999 ), ( 0.0 , 0.499999 )), ) -> list [ Scenario ]: \"\"\"Creates `n_scenarios` scenarios of the divide-the-pie domain all of `n_outcomes` outcomes and with different reserved value combinations that fall within `reserved_ranges` \"\"\" n = onein ( n_outcomes ) issues = ( make_issue ([ f \" { i } _ { n - 1 - i } \" for i in range ( n )], \"portions\" ), ) ufun_sets = [ tuple ( U ( values = ( TableFun ( { _ : int ( str ( _ ) . split ( \"_\" )[ k ]) / ( n - 1 ) for _ in issues [ 0 ] . all } ), ), name = f \" { uname }{ i } \" , reserved_value = ( r [ 0 ] + 1e-8 + random . random () * ( r [ 1 ] - r [ 0 ] - 1e-8 )), outcome_space = make_os ( issues , name = f \"DivideTyePie { i } \" ), ) for k , ( uname , r ) in enumerate ( zip (( \"First\" , \"Second\" ), reserved_ranges )) ) for i in range ( n_scenarios ) ] return [ Scenario ( outcome_space = ufuns [ 0 ] . outcome_space , # type: ignore We are sure this is not None ufuns = ufuns , ) for ufuns in ufun_sets ]","title":"function: make_scenarios"}]}